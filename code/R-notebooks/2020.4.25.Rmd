---
title: How to make executable shell scripts in Linux distributions
author: Sumeed Manzoor<br>[Chang Lab](https://changlab.uchicago.edu/) at the University of Chicago
date: April 25, 2020, *updated `r format(Sys.Date(), '%d %b, %Y')`*
output: 
  html_document:
    theme: sandstone
    highlight: textmate
    code_folding: "show"
    toc: true
    toc_float:
        collapsed: true
    toc_depth: 3
    includes:
        after_body: footer.html
---

<a href="http://yoyomanzoor.github.io/Chang-Lab-Notebook/" class="fa fa-home"></a>

<a href="https://changlab.uchicago.edu/" alt="The Chang Lab at the University of Chicago"><img src="https://img.shields.io/badge/Chang%20Lab--blue?style=flat-square&logo=jekyll" /></a>
<a href="https://github.com/Yoyomanzoor/MouseTrapper" alt="Github Repo"><img src="https://img.shields.io/badge/github%20repo--blueviolet?style=flat-square&logo=github" /></a>
<a href="" alt="tag"><img src="https://img.shields.io/badge/tags-programming%20|%20tutorial%20|%20rmarkdown-lightgrey?style=flat-square" /></a>

This is just a quick rundown of making a shell/bash script executable from anywhere in Linux. Of course, if you are in the directory with the script (we'll call the script script.sh), using `./script.sh` will run it in a subshell and `. ./script.sh` will run it in the currently running shell.

## Subprocess vs sourced

Scripts can be run in two ways. Subprocessed scripts are run using an interpreter declared at the start of the script, e.g. `#!/bin/sh` or `#!/usr/bin/env python`. Any commands run in the subprocess will not affect the currently running shell. For example, this script, script.sh, can be run from shell using the command `./script.sh`.

```bash
#!/bin/sh

cd ~/Documents
```

While one might expect the terminal to cd to `~/Documents`, nothing ends up happennig. This is because the shell opened a subprocess, which then moved to the directory, then ended the process, effectively doing nothing to the shell. Scripts can instead be sourced, which reads the lines of code in as a text and executes it line by line in the running shell. For example, is script.sh was rewritten:

```bash
cd ~/Documents
```

And now run using `. ./script.sh`, then the terminal will move to `~/Documents`, as expected.

## Via editing bash profile

Simple functions and additions can be added straight to the bash profile. Here's how the files look at home directory:

```
~
|
|- .bashrc
|- .bash_aliases
```

Then, in `.bashrc`, I add the following statements.

```bash
# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
```

In `.bash_aliases`, functions and aliases can be written. For example:

```bash
# User-defined functions and aliases to run at bash startup
  
# perform ls after cd
function cdls()
{
    builtin cd "$*"
    RESULT=$?
    if [ "$RESULT" -eq 0 ]; then
        ls -a
    fi
}
```

## Via PATH

### Add script temporarily.

```bash
export PATH=$PATH:</path/to/file>
```

### Add script permanently

This will make the script an executable for the user as soon as shell is started.

Open `~/.bashrc` using nano or vim, and add the line:

```bash
export PATH=$PATH:</path/to/file>
```

### Issues with path

A disadvantage to using path is that scripts that involve the shell itself and can't simply be run as a subprocess need to be called as `. script`. This can be worked around in a number of ways.

- If it is only needed for the session, `alias script=". script"` will work.
- If it is needed permanently, add `alias script=". script"` to `~/.bashrc` or to `~/.bash_aliases`.
- Adding as [function](#via-editing-bash-profile) does not have this issue.

## Via /usr/bin/local

Simply add the script to `/usr/bin/local` or `/usr/bin`, if in path.

## Interesting functions I found/wrote as I made this doc

### Added to Bash profile as functions in `~/.bash_aliases`

```bash
# perform ls after cd
function cdls()
{
    builtin cd "$*"
    RESULT=$?
    if [ "$RESULT" -eq 0 ]; then
        ls -a
    fi
}

# Go to chang lab notebook
function gtNotebook()
{
    builtin cd /home/yoyo/Documents/GitHub/Chang-Lab-Notebook
}
```

There's also one to knit rmarkdown files in console using knitr. It requires having Rstudio installed, then finding the Rstudio Pandoc location by opening Rstudio and running `Sys.getenv("RSTUDIO_PANDOC")` in console. That location is used in this script.

```bash
# Knit Rmarkdown files
function knit()
{
        R -e "Sys.setenv(RSTUDIO_PANDOC='/usr/lib/rstudio/bin/pandoc'); rmarkdown::render('$1')"
}
```

### Added to /usr/local/bin

I made a file `backup-id_rsa`.

```bash
#!/bin/sh

cp /home/yoyo/.ssh/id_rsa* /home/yoyo/.ssh/key_backup/
```

This script can be run as a subprocess, so doesn't need to be sourced.

